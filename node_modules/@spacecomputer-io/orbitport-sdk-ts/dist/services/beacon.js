"use strict";
/**
 * IPFS service for accessing beacon data from IPFS/IPNS
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeaconService = void 0;
const errors_1 = require("../utils/errors");
const retry_1 = require("../utils/retry");
/**
 * IPFS service class for beacon data access
 */
class BeaconService {
    constructor(config = {}, debug = false) {
        this.config = {
            gateway: 'https://ipfs.io',
            apiUrl: 'https://ipfs.io',
            timeout: 30000,
            enableFallback: true,
            ...config,
        };
        this.gateway = this.config.gateway;
        this.debug = debug;
        if (this.debug) {
            console.log('[OrbitportSDK] IPFS service initialized with config:', {
                gateway: this.gateway,
                apiUrl: this.config.apiUrl,
                enableFallback: this.config.enableFallback,
            });
        }
    }
    /**
     * Validates if a path is a valid IPFS/IPNS path
     * @param path - Path to validate
     * @returns True if valid IPFS/IPNS path
     */
    isValidPath(path) {
        return path.startsWith('/ipns/') || path.startsWith('/ipfs/');
    }
    /**
     * Reads beacon data from IPFS gateway
     * @param path - IPFS/IPNS path
     * @param timeout - Request timeout
     * @returns Promise resolving to beacon data
     */
    async readViaGateway(path, _timeout = this.config.timeout) {
        const url = `${this.gateway}${path}`;
        if (this.debug) {
            console.log('[OrbitportSDK] Reading from gateway:', url);
        }
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), _timeout);
            try {
                const response = await fetch(url, {
                    headers: { 'Cache-Control': 'no-cache' },
                    signal: controller.signal,
                });
                clearTimeout(timeoutId);
                if (!response.ok) {
                    throw new Error(`Gateway ${this.gateway} returned ${response.status}`);
                }
                const text = await response.text();
                return {
                    source: `gateway:${this.gateway}`,
                    text,
                };
            }
            catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }
        catch (error) {
            return {
                source: `gateway:${this.gateway}`,
                error: error instanceof Error ? error.message : 'Unknown gateway error',
            };
        }
    }
    /**
     * Reads beacon data from IPFS API
     * @param path - IPFS/IPNS path
     * @param timeout - Request timeout
     * @returns Promise resolving to beacon data
     */
    async readViaApi(path, _timeout = this.config.timeout) {
        if (!this.config.apiUrl) {
            return {
                source: `api:${this.config.apiUrl}`,
                error: 'IPFS API URL not configured',
            };
        }
        if (this.debug) {
            console.log('[OrbitportSDK] Reading from API:', path);
        }
        try {
            let effective = path;
            // Resolve IPNS to IPFS path if needed
            if (path.startsWith('/ipns/')) {
                const resolveUrl = `${this.config.apiUrl}/api/v0/name/resolve?arg=${encodeURIComponent(path)}`;
                const resolveResponse = await fetch(resolveUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Cache-Control': 'no-cache',
                    },
                });
                if (!resolveResponse.ok) {
                    throw new Error(`API resolve failed: ${resolveResponse.status}`);
                }
                const resolveData = await resolveResponse.json();
                if (!resolveData.Path) {
                    throw new Error('API resolve failed: no path returned');
                }
                effective = resolveData.Path.trim();
            }
            // Read content from IPFS using direct HTTP call
            const catUrl = `${this.config.apiUrl}/api/v0/cat?arg=${encodeURIComponent(effective)}`;
            const response = await fetch(catUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Cache-Control': 'no-cache',
                },
            });
            if (!response.ok) {
                throw new Error(`API cat failed: ${response.status}`);
            }
            const text = await response.text();
            return {
                source: `api:${this.config.apiUrl}`,
                text,
            };
        }
        catch (error) {
            return {
                source: `api:${this.config.apiUrl}`,
                error: error instanceof Error ? error.message : 'Unknown API error',
            };
        }
    }
    /**
     * Parses beacon JSON data
     * @param jsonText - Raw JSON text
     * @returns Parsed beacon data
     */
    parseBeacon(jsonText) {
        const obj = JSON.parse(jsonText);
        if (!obj ||
            typeof obj !== 'object' ||
            !obj.data ||
            typeof obj.data !== 'object') {
            throw new Error('Unexpected beacon JSON structure');
        }
        const { previous } = obj;
        const { sequence, timestamp, ctrng } = obj.data;
        // Convert timestamp to ISO string if it's a Unix timestamp
        const iso = typeof timestamp === 'number' && timestamp < 1e12
            ? new Date(timestamp * 1000).toISOString()
            : String(timestamp);
        return {
            previous,
            sequence,
            timestamp: iso,
            ctrng: Array.isArray(ctrng) ? ctrng : [],
        };
    }
    /**
     * Compares beacon data from different sources
     * @param gateway - Gateway beacon data
     * @param api - API beacon data
     * @returns Comparison result
     */
    compareBeaconData(gateway, api) {
        const match = gateway &&
            api &&
            gateway.sequence === api.sequence &&
            gateway.previous === api.previous;
        const differences = gateway && api && !match
            ? {
                sequence: gateway.sequence !== api.sequence
                    ? {
                        gateway: gateway.sequence,
                        api: api.sequence,
                    }
                    : undefined,
                previous: gateway.previous !== api.previous
                    ? {
                        gateway: gateway.previous || '',
                        api: api.previous || '',
                    }
                    : undefined,
            }
            : undefined;
        return {
            gateway,
            api,
            match: !!match,
            differences,
        };
    }
    /**
     * Reads beacon data from multiple sources
     * @param path - IPFS/IPNS path
     * @param sources - Sources to read from
     * @param timeout - Request timeout
     * @returns Promise resolving to beacon data from all sources
     */
    async readFromSources(path, sources = ['gateway', 'api'], timeout = this.config.timeout) {
        const tasks = [];
        if (sources.includes('gateway')) {
            tasks.push(this.readViaGateway(path, timeout));
        }
        if (sources.includes('api')) {
            tasks.push(this.readViaApi(path, timeout));
        }
        return Promise.all(tasks);
    }
    /**
     * Gets beacon data from IPFS/IPNS
     * @param request - Beacon request parameters
     * @param options - Request options
     * @returns Promise resolving to beacon data
     */
    async getBeacon(request, options = {}) {
        const { path, sources = ['both'], enableComparison = false } = request;
        const requestOptions = {
            timeout: options.timeout || this.config.timeout,
            retries: options.retries || 3,
        };
        if (!this.isValidPath(path)) {
            throw new errors_1.OrbitportSDKError('Invalid path: must start with /ipns/ or /ipfs/', errors_1.ERROR_CODES.INVALID_RESPONSE);
        }
        if (this.debug) {
            console.log('[OrbitportSDK] Getting beacon data for path:', path);
        }
        try {
            const result = await (0, retry_1.withRetry)(async () => {
                const sourceList = sources.includes('both')
                    ? ['gateway', 'api']
                    : sources;
                const sources_data = await this.readFromSources(path, sourceList, requestOptions.timeout);
                // Check for errors
                const errors = sources_data.filter((s) => s.error);
                if (errors.length === sources_data.length) {
                    throw new errors_1.OrbitportSDKError(`All sources failed: ${errors.map((e) => e.error).join(', ')}`, errors_1.ERROR_CODES.NETWORK_ERROR);
                }
                // Parse successful sources
                const parsedData = [];
                for (const source of sources_data) {
                    if (source.text) {
                        try {
                            const data = this.parseBeacon(source.text);
                            parsedData.push({ source: source.source, data });
                        }
                        catch (error) {
                            if (this.debug) {
                                console.warn(`[OrbitportSDK] Parse error for ${source.source}:`, error);
                            }
                        }
                    }
                }
                if (parsedData.length === 0) {
                    throw new errors_1.OrbitportSDKError('No valid beacon data found from any source', errors_1.ERROR_CODES.INVALID_RESPONSE);
                }
                // Return single result or comparison
                if (enableComparison && parsedData.length >= 2) {
                    const gateway = parsedData.find((p) => p.source.includes('gateway'))?.data ||
                        null;
                    const api = parsedData.find((p) => p.source.includes('api'))?.data || null;
                    return this.compareBeaconData(gateway, api);
                }
                else {
                    // Return the first successful result
                    return parsedData[0].data;
                }
            }, {
                ...retry_1.RETRY_STRATEGIES.standard,
                maxAttempts: requestOptions.retries,
            }, (error, attempt) => {
                if (this.debug) {
                    console.warn(`[OrbitportSDK] Beacon request attempt ${attempt} failed:`, error.message);
                }
            });
            const metadata = {
                timestamp: Date.now(),
            };
            return {
                data: result,
                metadata,
                success: true,
            };
        }
        catch (error) {
            if (this.debug) {
                console.error('[OrbitportSDK] Beacon request failed:', error);
            }
            throw error;
        }
    }
    /**
     * Gets beacon data with automatic fallback
     * @param path - IPFS/IPNS path
     * @param options - Request options
     * @returns Promise resolving to beacon data
     */
    async getBeaconWithFallback(path, options = {}) {
        if (!this.config.enableFallback) {
            const result = await this.getBeacon({ path }, options);
            if ('sequence' in result.data) {
                return result;
            }
            throw new errors_1.OrbitportSDKError('Unexpected response type from getBeacon', errors_1.ERROR_CODES.INVALID_RESPONSE);
        }
        // Try gateway first, then API as fallback
        try {
            const result = await this.getBeacon({ path, sources: ['gateway'] }, options);
            if ('sequence' in result.data) {
                return result;
            }
            throw new errors_1.OrbitportSDKError('Unexpected response type from gateway', errors_1.ERROR_CODES.INVALID_RESPONSE);
        }
        catch (_error) {
            if (this.debug) {
                console.log('[OrbitportSDK] Gateway failed, trying API fallback');
            }
            const result = await this.getBeacon({ path, sources: ['api'] }, options);
            if ('sequence' in result.data) {
                return result;
            }
            throw new errors_1.OrbitportSDKError('Unexpected response type from API', errors_1.ERROR_CODES.INVALID_RESPONSE);
        }
    }
    /**
     * Gets beacon data with block traversal
     * @param request - Beacon request parameters with block traversal
     * @param options - Request options
     * @returns Promise resolving to beacon data at specified block
     */
    async getBeaconWithBlockTraversal(request, options = {}) {
        const { block = 'INF' } = request;
        if (block === 'INF') {
            // No traversal needed, get latest block
            return this.getBeacon(request, options);
        }
        if (typeof block !== 'number' || block < 0) {
            throw new errors_1.OrbitportSDKError('Block number must be a non-negative integer', errors_1.ERROR_CODES.INVALID_REQUEST);
        }
        if (this.debug) {
            console.log(`[OrbitportSDK] Starting block traversal to block ${block}`);
        }
        // Get the latest block first to check current sequence
        const latestResult = await this.getBeacon(request, options);
        let currentBeacon;
        if ('sequence' in latestResult.data) {
            currentBeacon = latestResult.data;
        }
        else if ('gateway' in latestResult.data) {
            currentBeacon = latestResult.data.gateway || latestResult.data.api;
        }
        else {
            throw new errors_1.OrbitportSDKError('Invalid beacon data structure', errors_1.ERROR_CODES.INVALID_RESPONSE);
        }
        const currentSequence = currentBeacon.sequence;
        if (block > currentSequence) {
            throw new errors_1.OrbitportSDKError(`Requested block ${block} is greater than current block ${currentSequence}`, errors_1.ERROR_CODES.INVALID_REQUEST);
        }
        if (block === currentSequence) {
            // Already at the requested block
            return latestResult;
        }
        // Traverse back through the chain
        let targetBeacon = currentBeacon;
        let traversedBlocks = 0;
        const maxTraversal = currentSequence - block;
        while (traversedBlocks < maxTraversal && targetBeacon.previous) {
            if (this.debug) {
                console.log(`[OrbitportSDK] Traversing from block ${targetBeacon.sequence} to previous block`);
            }
            // Get the previous block
            const previousPath = targetBeacon.previous;
            const previousResult = await this.getBeacon({ ...request, path: previousPath }, options);
            let previousBeacon;
            if ('sequence' in previousResult.data) {
                previousBeacon = previousResult.data;
            }
            else if ('gateway' in previousResult.data) {
                previousBeacon =
                    previousResult.data.gateway || previousResult.data.api;
            }
            else {
                throw new errors_1.OrbitportSDKError('Invalid previous beacon data structure', errors_1.ERROR_CODES.INVALID_RESPONSE);
            }
            targetBeacon = previousBeacon;
            traversedBlocks++;
            if (targetBeacon.sequence === block) {
                // Found the target block
                break;
            }
            if (targetBeacon.sequence < block) {
                throw new errors_1.OrbitportSDKError(`Block ${block} not found in chain. Last available block: ${targetBeacon.sequence}`, errors_1.ERROR_CODES.INVALID_REQUEST);
            }
        }
        if (targetBeacon.sequence !== block) {
            throw new errors_1.OrbitportSDKError(`Failed to reach block ${block}. Current block: ${targetBeacon.sequence}`, errors_1.ERROR_CODES.INVALID_REQUEST);
        }
        if (this.debug) {
            console.log(`[OrbitportSDK] Successfully traversed to block ${block} (${traversedBlocks} steps)`);
        }
        // Return the target beacon data in the same format as the original request
        if ('sequence' in latestResult.data) {
            return {
                data: targetBeacon,
                metadata: latestResult.metadata,
                success: true,
            };
        }
        else {
            // Return as comparison format but with single beacon
            return {
                data: {
                    gateway: targetBeacon,
                    api: null,
                    match: true,
                },
                metadata: latestResult.metadata,
                success: true,
            };
        }
    }
    /**
     * Updates IPFS configuration
     * @param newConfig - New IPFS configuration
     */
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
        if (newConfig.gateway) {
            this.gateway = newConfig.gateway;
        }
        if (newConfig.apiUrl) {
            // No need to update API client since we're using direct HTTP calls
            if (this.debug) {
                console.log('[OrbitportSDK] Updated IPFS API URL:', newConfig.apiUrl);
            }
        }
        if (this.debug) {
            console.log('[OrbitportSDK] IPFS configuration updated:', this.config);
        }
    }
}
exports.BeaconService = BeaconService;
//# sourceMappingURL=beacon.js.map
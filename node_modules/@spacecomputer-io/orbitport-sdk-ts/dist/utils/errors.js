"use strict";
/**
 * Error handling utilities for the Orbitport SDK
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERROR_CODES = exports.OrbitportSDKError = void 0;
exports.createErrorFromAPIResponse = createErrorFromAPIResponse;
exports.createNetworkError = createNetworkError;
exports.createConfigError = createConfigError;
exports.createValidationError = createValidationError;
exports.isRetryableError = isRetryableError;
exports.isAuthError = isAuthError;
exports.formatErrorMessage = formatErrorMessage;
/**
 * Custom error class for Orbitport SDK errors
 */
class OrbitportSDKError extends Error {
    constructor(message, code, status, details) {
        super(message);
        this.name = 'OrbitportSDKError';
        this.code = code;
        this.status = status;
        this.details = details;
        // Maintains proper stack trace for where our error was thrown
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, OrbitportSDKError);
        }
    }
}
exports.OrbitportSDKError = OrbitportSDKError;
/**
 * Error codes used throughout the SDK
 */
exports.ERROR_CODES = {
    // Authentication errors
    AUTH_FAILED: 'AUTH_FAILED',
    INVALID_CREDENTIALS: 'INVALID_CREDENTIALS',
    TOKEN_EXPIRED: 'TOKEN_EXPIRED',
    TOKEN_REFRESH_FAILED: 'TOKEN_REFRESH_FAILED',
    // Configuration errors
    INVALID_CONFIG: 'INVALID_CONFIG',
    MISSING_CLIENT_ID: 'MISSING_CLIENT_ID',
    MISSING_CLIENT_SECRET: 'MISSING_CLIENT_SECRET',
    // Network errors
    NETWORK_ERROR: 'NETWORK_ERROR',
    TIMEOUT: 'TIMEOUT',
    CONNECTION_FAILED: 'CONNECTION_FAILED',
    // API errors
    API_ERROR: 'API_ERROR',
    RATE_LIMITED: 'RATE_LIMITED',
    SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',
    INVALID_RESPONSE: 'INVALID_RESPONSE',
    // Storage errors
    STORAGE_ERROR: 'STORAGE_ERROR',
    STORAGE_UNAVAILABLE: 'STORAGE_UNAVAILABLE',
    // Validation errors
    VALIDATION_ERROR: 'VALIDATION_ERROR',
    INVALID_PARAMETERS: 'INVALID_PARAMETERS',
    INVALID_REQUEST: 'INVALID_REQUEST',
    // Service-specific errors
    CTRNG_ERROR: 'CTRNG_ERROR',
    PROVIDER_UNAVAILABLE: 'PROVIDER_UNAVAILABLE',
    FALLBACK_FAILED: 'FALLBACK_FAILED',
    // Unknown errors
    UNKNOWN_ERROR: 'UNKNOWN_ERROR',
};
/**
 * Creates an OrbitportSDKError from an API error response
 */
function createErrorFromAPIResponse(apiError, status) {
    const code = apiError.error_code || exports.ERROR_CODES.API_ERROR;
    const message = apiError.error_description || apiError.error || 'API Error';
    return new OrbitportSDKError(message, code, status, apiError.details);
}
/**
 * Creates an OrbitportSDKError from a network error
 */
function createNetworkError(error, status) {
    let code = exports.ERROR_CODES.NETWORK_ERROR;
    let message = error.message;
    if (error.name === 'AbortError' || message.includes('timeout')) {
        code = exports.ERROR_CODES.TIMEOUT;
        message = 'Request timeout';
    }
    else if (message.includes('fetch')) {
        code = exports.ERROR_CODES.CONNECTION_FAILED;
        message = 'Connection failed';
    }
    return new OrbitportSDKError(message, code, status, { originalError: error });
}
/**
 * Creates an OrbitportSDKError for configuration issues
 */
function createConfigError(message, details) {
    return new OrbitportSDKError(message, exports.ERROR_CODES.INVALID_CONFIG, undefined, details);
}
/**
 * Creates an OrbitportSDKError for validation issues
 */
function createValidationError(message, details) {
    return new OrbitportSDKError(message, exports.ERROR_CODES.VALIDATION_ERROR, undefined, details);
}
/**
 * Determines if an error is retryable
 */
function isRetryableError(error) {
    const retryableCodes = [
        exports.ERROR_CODES.NETWORK_ERROR,
        exports.ERROR_CODES.TIMEOUT,
        exports.ERROR_CODES.CONNECTION_FAILED,
        exports.ERROR_CODES.SERVICE_UNAVAILABLE,
        exports.ERROR_CODES.RATE_LIMITED,
        exports.ERROR_CODES.PROVIDER_UNAVAILABLE,
    ];
    return retryableCodes.includes(error.code);
}
/**
 * Determines if an error is related to authentication
 */
function isAuthError(error) {
    const authCodes = [
        exports.ERROR_CODES.AUTH_FAILED,
        exports.ERROR_CODES.INVALID_CREDENTIALS,
        exports.ERROR_CODES.TOKEN_EXPIRED,
        exports.ERROR_CODES.TOKEN_REFRESH_FAILED,
    ];
    return authCodes.includes(error.code);
}
/**
 * Error message formatter for user-friendly error messages
 */
function formatErrorMessage(error) {
    const baseMessage = error.message;
    switch (error.code) {
        case exports.ERROR_CODES.AUTH_FAILED:
            return 'Authentication failed. Please check your credentials.';
        case exports.ERROR_CODES.INVALID_CREDENTIALS:
            return 'Invalid client ID or client secret.';
        case exports.ERROR_CODES.TOKEN_EXPIRED:
            return 'Authentication token has expired. Please re-authenticate.';
        case exports.ERROR_CODES.NETWORK_ERROR:
            return 'Network error occurred. Please check your connection.';
        case exports.ERROR_CODES.TIMEOUT:
            return 'Request timed out. Please try again.';
        case exports.ERROR_CODES.RATE_LIMITED:
            return 'Rate limit exceeded. Please wait before making another request.';
        case exports.ERROR_CODES.SERVICE_UNAVAILABLE:
            return 'Service is temporarily unavailable. Please try again later.';
        case exports.ERROR_CODES.INVALID_CONFIG:
            return 'Invalid SDK configuration. Please check your settings.';
        default:
            return baseMessage;
    }
}
//# sourceMappingURL=errors.js.map
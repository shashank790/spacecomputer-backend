"use strict";
/**
 * Authentication service for the Orbitport SDK
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthService = void 0;
const errors_1 = require("../utils/errors");
const retry_1 = require("../utils/retry");
const validation_1 = require("../utils/validation");
/**
 * Authentication service class
 */
class AuthService {
    constructor(config, storage, eventHandler, debug = false) {
        this.tokenPromise = undefined;
        this.config = config;
        this.storage = storage;
        this.eventHandler = eventHandler || (() => { });
        this.debug = debug;
    }
    /**
     * Gets a valid access token, refreshing if necessary
     */
    async getValidToken() {
        // Prevent multiple simultaneous token requests
        if (this.tokenPromise) {
            return this.tokenPromise;
        }
        this.tokenPromise = this._getValidToken();
        try {
            const token = await this.tokenPromise;
            return token;
        }
        finally {
            this.tokenPromise = undefined;
        }
    }
    /**
     * Internal method to get valid token
     */
    async _getValidToken() {
        try {
            // Try to get existing token from storage
            const existingToken = await this.storage.get();
            if (existingToken && !(0, validation_1.isTokenExpired)(existingToken)) {
                if (this.debug) {
                    console.log('[OrbitportSDK] Using existing valid token');
                }
                return existingToken;
            }
            if (this.debug) {
                console.log('[OrbitportSDK] Token expired or not found, requesting new token');
            }
            // Request new token
            const tokenData = await this.requestNewToken();
            if (!tokenData) {
                throw new errors_1.OrbitportSDKError('Failed to obtain access token', errors_1.ERROR_CODES.AUTH_FAILED);
            }
            // Store the new token
            await this.storage.set(tokenData.access_token, tokenData.expires_at);
            // Emit token refresh event
            this.emitEvent({
                type: 'token_refresh',
                timestamp: Date.now(),
                data: { expires_at: tokenData.expires_at },
            });
            return tokenData.access_token;
        }
        catch (error) {
            if (this.debug) {
                console.error('[OrbitportSDK] Token retrieval failed:', error);
            }
            // Clear invalid token from storage
            await this.storage.clear();
            throw error;
        }
    }
    /**
     * Requests a new access token from the authentication server
     */
    async requestNewToken() {
        const authUrl = `${this.config.authUrl}/oauth/token`;
        const audience = `${this.config.apiUrl}/api`;
        const requestBody = {
            client_id: this.config.clientId,
            client_secret: this.config.clientSecret,
            audience,
            grant_type: 'client_credentials',
        };
        if (this.debug) {
            console.log('[OrbitportSDK] Requesting token from:', authUrl);
        }
        try {
            const response = await (0, retry_1.withRetry)(async () => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);
                try {
                    const response = await fetch(authUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal,
                    });
                    clearTimeout(timeoutId);
                    return response;
                }
                catch (error) {
                    clearTimeout(timeoutId);
                    throw error;
                }
            }, retry_1.RETRY_STRATEGIES.standard, (error, attempt) => {
                if (this.debug) {
                    console.warn(`[OrbitportSDK] Token request attempt ${attempt} failed:`, error.message);
                }
            });
            if (!response.ok) {
                let apiError;
                try {
                    apiError = await response.json();
                }
                catch {
                    apiError = {
                        error: 'Unknown error',
                        error_description: 'Failed to parse error response',
                    };
                }
                throw (0, errors_1.createErrorFromAPIResponse)(apiError, response.status);
            }
            const tokenResponse = await response.json();
            if (!tokenResponse.access_token) {
                throw new errors_1.OrbitportSDKError('Invalid token response: missing access_token', errors_1.ERROR_CODES.INVALID_RESPONSE);
            }
            // Calculate expiration time
            const expiresAt = Date.now() / 1000 + (tokenResponse.expires_in || 3600);
            return {
                access_token: tokenResponse.access_token,
                expires_at: expiresAt,
                token_type: tokenResponse.token_type || 'Bearer',
            };
        }
        catch (error) {
            if (error instanceof errors_1.OrbitportSDKError) {
                throw error;
            }
            // Handle network errors
            if (error instanceof Error) {
                if (error.name === 'AbortError') {
                    throw new errors_1.OrbitportSDKError('Token request timeout', errors_1.ERROR_CODES.TIMEOUT);
                }
                throw (0, errors_1.createNetworkError)(error);
            }
            throw new errors_1.OrbitportSDKError('Unknown error during token request', errors_1.ERROR_CODES.UNKNOWN_ERROR, undefined, error);
        }
    }
    /**
     * Clears the stored token
     */
    async clearToken() {
        await this.storage.clear();
        this.emitEvent({
            type: 'token_refresh',
            timestamp: Date.now(),
            data: { action: 'cleared' },
        });
    }
    /**
     * Checks if the current token is valid
     */
    async isTokenValid() {
        try {
            const token = await this.storage.get();
            return token !== null && !(0, validation_1.isTokenExpired)(token);
        }
        catch {
            return false;
        }
    }
    /**
     * Gets token information without refreshing
     */
    async getTokenInfo() {
        try {
            const token = await this.storage.get();
            if (!token) {
                return { valid: false };
            }
            if ((0, validation_1.isTokenExpired)(token)) {
                return { valid: false };
            }
            // Parse token to get expiration
            const parts = token.split('.');
            if (parts.length >= 2) {
                const payload = JSON.parse(atob(parts[1]));
                return { valid: true, expiresAt: payload.exp };
            }
            return { valid: true };
        }
        catch {
            return { valid: false };
        }
    }
    /**
     * Emits an SDK event
     */
    emitEvent(event) {
        if (this.eventHandler) {
            try {
                this.eventHandler(event);
            }
            catch (error) {
                if (this.debug) {
                    console.warn('[OrbitportSDK] Event handler error:', error);
                }
            }
        }
    }
    /**
     * Updates the configuration
     */
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
    }
    /**
     * Updates the event handler
     */
    setEventHandler(handler) {
        this.eventHandler = handler;
    }
    /**
     * Sets debug mode
     */
    setDebug(debug) {
        this.debug = debug;
    }
}
exports.AuthService = AuthService;
//# sourceMappingURL=auth.js.map
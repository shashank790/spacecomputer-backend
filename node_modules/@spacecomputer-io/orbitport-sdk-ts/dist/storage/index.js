"use strict";
/**
 * Token storage implementations for different environments
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomTokenStorage = exports.FileTokenStorage = exports.MemoryTokenStorage = exports.BrowserTokenStorage = void 0;
exports.createDefaultStorage = createDefaultStorage;
exports.createStorage = createStorage;
/**
 * Browser localStorage implementation
 */
class BrowserTokenStorage {
    constructor(key = 'orbitport_token') {
        this.key = key;
    }
    async get() {
        if (typeof window === 'undefined' || !window.localStorage) {
            return null;
        }
        try {
            const stored = window.localStorage.getItem(this.key);
            if (!stored)
                return null;
            const tokenData = JSON.parse(stored);
            // Check if token is expired
            if (Date.now() >= tokenData.expires_at * 1000) {
                await this.clear();
                return null;
            }
            return tokenData.access_token;
        }
        catch (error) {
            console.warn('Failed to retrieve token from localStorage:', error);
            return null;
        }
    }
    async set(token, expiresAt) {
        if (typeof window === 'undefined' || !window.localStorage) {
            throw new Error('localStorage is not available');
        }
        try {
            const tokenData = {
                access_token: token,
                expires_at: expiresAt,
                stored_at: Date.now(),
            };
            window.localStorage.setItem(this.key, JSON.stringify(tokenData));
        }
        catch (error) {
            console.warn('Failed to store token in localStorage:', error);
            throw error;
        }
    }
    async clear() {
        if (typeof window === 'undefined' || !window.localStorage) {
            return;
        }
        try {
            window.localStorage.removeItem(this.key);
        }
        catch (error) {
            console.warn('Failed to clear token from localStorage:', error);
        }
    }
}
exports.BrowserTokenStorage = BrowserTokenStorage;
/**
 * Node.js memory storage implementation
 */
class MemoryTokenStorage {
    constructor() {
        this.token = null;
        this.expiresAt = 0;
    }
    async get() {
        if (!this.token || Date.now() >= this.expiresAt * 1000) {
            this.token = null;
            return null;
        }
        return this.token;
    }
    async set(token, expiresAt) {
        this.token = token;
        this.expiresAt = expiresAt;
    }
    async clear() {
        this.token = null;
        this.expiresAt = 0;
    }
}
exports.MemoryTokenStorage = MemoryTokenStorage;
/**
 * Node.js file system storage implementation
 */
class FileTokenStorage {
    constructor(filePath = '.orbitport_token') {
        this.filePath = filePath;
        // Dynamic import to avoid bundling fs in browser builds
        try {
            this.fs = require('fs');
        }
        catch (_error) {
            throw new Error('File system access not available in this environment');
        }
    }
    async get() {
        try {
            if (!this.fs.existsSync(this.filePath)) {
                return null;
            }
            const data = this.fs.readFileSync(this.filePath, 'utf8');
            const tokenData = JSON.parse(data);
            // Check if token is expired
            if (Date.now() >= tokenData.expires_at * 1000) {
                await this.clear();
                return null;
            }
            return tokenData.access_token;
        }
        catch (error) {
            console.warn('Failed to retrieve token from file:', error);
            return null;
        }
    }
    async set(token, expiresAt) {
        try {
            const tokenData = {
                access_token: token,
                expires_at: expiresAt,
                stored_at: Date.now(),
            };
            this.fs.writeFileSync(this.filePath, JSON.stringify(tokenData, null, 2));
        }
        catch (error) {
            console.warn('Failed to store token in file:', error);
            throw error;
        }
    }
    async clear() {
        try {
            if (this.fs.existsSync(this.filePath)) {
                this.fs.unlinkSync(this.filePath);
            }
        }
        catch (error) {
            console.warn('Failed to clear token file:', error);
        }
    }
}
exports.FileTokenStorage = FileTokenStorage;
/**
 * Custom storage implementation that allows user-defined storage
 */
class CustomTokenStorage {
    constructor(getter, setter, clearer) {
        this.getter = getter;
        this.setter = setter;
        this.clearer = clearer;
    }
    async get() {
        return this.getter();
    }
    async set(token, expiresAt) {
        return this.setter(token, expiresAt);
    }
    async clear() {
        return this.clearer();
    }
}
exports.CustomTokenStorage = CustomTokenStorage;
/**
 * Factory function to create appropriate storage based on environment
 */
function createDefaultStorage() {
    // Check if we're in a browser environment
    if (typeof window !== 'undefined' && window.localStorage) {
        return new BrowserTokenStorage();
    }
    // Check if we're in Node.js environment
    if (typeof process !== 'undefined' &&
        process.versions &&
        process.versions.node) {
        return new MemoryTokenStorage();
    }
    // Fallback to memory storage
    return new MemoryTokenStorage();
}
/**
 * Creates a storage instance with specific configuration
 */
function createStorage(options) {
    switch (options.type) {
        case 'browser':
            return new BrowserTokenStorage(options.key);
        case 'memory':
            return new MemoryTokenStorage();
        case 'file':
            return new FileTokenStorage(options.filePath);
        case 'custom':
            if (!options.customStorage) {
                throw new Error("Custom storage instance is required for 'custom' type");
            }
            return options.customStorage;
        default:
            throw new Error(`Unsupported storage type: ${options.type}`);
    }
}
//# sourceMappingURL=index.js.map